设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。
其实很多的设计模式是在日常的搬砖过程中一直在使用的，但是就是说不上名字，今天总结一下

## 工厂模式

工厂模式是设计模式中很常见的一种，比如最近的一个活，业务大概是这样的。
我们要创建一个存储卷，在创建的过程中有如下的几种参数：

1. 名字-字符串
2. 卷容量大小-大于 0 的整数
3. qos 参数-选择 qos 或者直接创建新的 qos
4. 存储池选择

上面的这几个参数在卷的生命周期中很多地方都要用到，比如在卷列表中有个修改卷的名称，那么创建和修改的校验逻辑就是一样的，同样的在 qos 列表中创建 qos 和编辑 qos 所需要的逻辑和创建卷的时候也是一样的。
那么这时候就需要有一个基础工厂，让我们把这部分的代码做成基类，然后通过继承让其他的组件继承这个基类，这时候其他组件中就有了名字校验，qos 相关的逻辑。如果别的地方继承了基类，但是有特殊的需要的话，就直接在自己的业务中进行添加，不去更新基类的代码。

工厂模式中有个很重要的点，就是工厂内的东西是属于公共的，不去参与工厂生成的业务的逻辑，而通过工厂继承的业务就可以去扩展工厂内的逻辑。所谓的封闭和开放。
也就是对自己（工厂内部）封闭，对外（继承工厂生成的业务组件）开放添加拓展逻辑

## 单列模式

**意图就是保证一个类只有一个实例，并在全局提供访问这个实例的方法。**

下面有个基础的 class 然后 new 一下会出来两个完全不一样的对象

```js
class TestSingleMode {
  constructor(name) {
    this.name = name;
  }

  hello() {
    console.log(this.name);
  }
}

const T1 = new TestSingleMode("T1");
const T2 = new TestSingleMode("T2");

T1 === T2; // false
```

因为在 new 的这个过程中，会完全开辟两个新的内存空间，去存放 T1 和 T2 这两个对象。所以不管是内容还是引用类型的地址，都是不一样的。这也是符合要求的。但是我们现在就想让这俩完全不一样的对象，变成引用地址是同一个，那么这就是单列模式的由来了。
单列模式有很多好处，比如 redux 的全局数据流，就是一种单列模式， state 里的数据是全局唯一，提供了修改 state 里面数据的方法，通过约定好的 action 去修改。还有像多人游戏的共享物品啊，也是要全局唯一的。给一个方法让所有的组件都可以去修改，修改完了以后其他的组件也可以得到修改完的数据。

```js
// 单列模式
class SignleMode {
  constructor() {
    this.number = 0;
  }
  static getinstance() {
    if (!this.instance) {
      SignleMode.instance = new SignleMode();
    }

    return SignleMode.instance;
  }

  add() {
    if (!this.number) {
      this.number = 1;
    } else {
      this.number += 1;
    }
  }
}
```
