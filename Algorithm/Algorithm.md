算法部分为 Sorting,Searching,Recursion,Backtracking,DP,DFS,BFS,Union Find Big O,Time vs space

## Sorting

排序算法有很多，最简单的就要数冒泡了，这个就不写了很简单。
目前我查到的 v8 在长度小于 10 的 时候是采用的插入排序，当大于 10 的时候采用的是插入排序，因此在这里就重点掌握这两种排序的算法。

### 插入排序

插入的工作原理是通过构建有序的序列，对没有排序的数据，在已经排序的序列中从后向前扫描，找到相应的位置并插入。插入排序在实现上通常是采用 in-place 排序，既只需要用到 O(1)的额外空间的排序。因而在扫描的过程中，需要反复把已经排序的元素逐步向后进行位移，为最新元素提供插入空间。
一般来说算法的实现是这样的

1. 从第一个元素开始，元素被认为是已经被排序。
2. 取出下一个元素，在已经排序的元素中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移动到下一个位置。
4. 重复步骤 3 ，直到找到已经排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置后。
6. 重复步骤 2~5

**插入排序的算法复杂度**
如果是把 n 个元素的序列进行升序排列或者降序排序，那么插入排序就存在着最好和最坏的情况，最好的情况是序列已经是升序排序了，在这种情况下，需要进行的比较操作是 n-1 即可。最坏的情况就是序列是降序排列，那么此时需要进行的比较就是 $\frac{1}{2}$n(n-1)，插入排序的赋值操作是比较操作的次数减去 n-1 次，因为在 n - 1 循环中，每一次循环的比较都比赋值多一个，多在最后的那个比较并不能带来赋值。平均来说插入排序的算法复杂度是

## Searching

## Recursion

## Backtracking

## DP

## DFS

## BFS

## Union Find Big O

## Time vs space
