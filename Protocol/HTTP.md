## HTTP 的方法

- http1.0 的方法 get post HEAD
- http1.1 新增五种请求方法 options put delete trace 和 connect

## 上面的方法的具体作用

- GET 通常用于服务器请求某些资源
- HEAD 请求资源的头部信息，并且这些头部和 HTTP GET 方法返回的一样，这个请求方法的一个使用场景是下载一个大文件前先获取这个文件的大小再决定是不是要下载，可以节约带宽资源
- OPTIONS 用于获取目的资源所支持的通信选项，也叫预请求。用来检测实际发出的请求是不是可以被服务器接受。
- POST 发送数据给服务器
- PUT 用户新增资源或者使用请求中的有效负载替换目标资源的表现形式
- DELETE 用于删除指定的资源
- PATCH 用于对资源进行部分修改。
- CONNECT HTTP 1.1 协议中预留给能够将连接改为管道方式的代理服务器
- TRACE 回显服务器收到的请求，主要用于测试或者诊断

## 跨域

跨域实现的方案有很多， JSONP ，Nginx 中间人，Windows.name CORS

### JSONP

**JSONP**：这是一种非常古老的跨域手段，利用 HTML 中的 script 标签不受同源策略限制的特性做跨域操作。

- JSONP 的优点是实现简单，兼容性非常好
- 缺点是 只支持 get 请求，因为 script 标签只能 get，有安全性的隐患，比如可能会有 xss 攻击

**原理**：利用 script 发起 get 请求，然后在 callback 函数中获取返回的数据。

### Nginx

使用 Nginx 作为跳板机，在服务器端进行转发到别的 IP 服务器上，这样就规避了同源效应。

```conf
location /api {
    rewirte ^/b/(.*)$ /$1 break; # 去除本地接口中的 api 前缀，否则会报错 404
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_pass http://192.168.0.103:8080; # 转发地址
}

```

### CORS

跨资源共享，使用额外的 HTTP 头信息来告诉浏览器，让运行在一个远端上的 web 被准许访问来自不同源服务器上的指定资源。主要是在 HTTP head 中的以下三个头信息控制

1. Access-Control-Allow-Origin 后面是跟的跨域服务器网址也可以直接写 \* ，那么就是所有的网址都可以
2. Access-Control-Allow-Methods 后面是跟的允许跨域的方法 GET PUT POST DELETE 等等
3. Access-Control-Allow-Headers 浏览器支持的所有头部信息字段。

CORS 比 JSONP 强大的地方在于可以支持更多的请求方法，而不是只有一个 GET

### window.name

window.name 在不同的页面甚至不同的域名加载以后依旧是存在的，并且可以支持非常长的 name 字符串。

### postMessage 函数

在 H5 的 XMLHTTPRequest 里面有个 api 叫 postMessage ，这个方法允许来自不同源的脚本采用异步的方式进行有限的通信。可以实现跨域的消息传递

## UDP 和 TCP

TCP 是面向连接，全双工，可靠（重传机制），有序，有拥塞控制机制，传输速度比较慢（相对 UDP），头部大小 20-60 字节

UDP 是无连接，不是全双工，不可靠（丢包以后数据丢失），无序，无拥塞控制，传输速度快，头部大小 8 字节

## HTTP 的部首

### 通用的部首

- Cache-Control 控制缓存
- connect 链接管理，逐条首部
- Transfor-Encoding 报文主体的传输编码格式

### 请求的首部

- Accept 客户端或者代理能够处理的媒体类型
- If-Match 比较实体标记（ETage）在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag 值时才会返回资源。而对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。ETag 之间的比较使用的是强比较算法，即只有在每一个字节都相同的情况下，才可以认为两个文件是相同的。 [mdn if-match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match) 和协商缓存有关系
- If-None-Match 对于 GET 和 HEAD 方法来说，当且仅当服务器上没有任何资源的 Etag 属性值于这个首部中列出的相匹配的时候，服务器端才会返回所请求的资源。和 if-match 相反
- If-Modify-Since 在请求头消息中，有这个头部消息的是条件式的请求，只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源。如果资源发生了修改，那么就会返回 412 错误
- Range 实体的字节范围请求
- Authorization 用户认证信息
- Host 请求资源所在的服务器
- User-Agent 客户端程序信息，操作系统啊，软件版本啊，开发商啊之类的

### 响应的首部信息

从服务器端向客户端发起响应的时候，使用的字段

- Location 使得客户端重定向的 URI
- ETag 能够表示资源唯一资源的字符串
- Server 服务器的信息

### 实体首部字段

针对请求报文和响应报文的实体部分使用首部

- Allow 资源可支持的 HTTP 请求的方法 Allow: GET, POST, HEAD ，一般和状态码 405 有关系
- Last-Modified 资源最后被修改时间
- Expires 实体资源文件的过期时间，和协商缓存有关系。

## 状态码

### 2xx

- 200 表示请求正在被正确的处理
- 206 进行范围请求

### 3xx

- 301 永久性重定向，表示已经分配了新的 URL
- 302 临时性重定向，表示资源临时分配了新的 URL
- 304 服务器允许访问资源，但是有缓存可以使用
- 307 临时重定向，和 302 类似
- 308 永久重定向，和 301 的区别是 308 的请求方法和消息主体不会发生变化，而 301 有可能会变成 get 方法。

### 4xx

- 400 请求语义错误，或者参数错误
- 401 没有权限，用户验证错误
- 405 Method 不被允许
- 403 请求被拒绝

### 5xx

- 500 在服务器执行的时候发生了错误

### 302 307 303

302 是 http1.0 的状态码，在 http1.1 中为了细分临时重定向，划分出来 303，307
**303**：表示客户端应该使用 get 方法请求，它会把 post 转成 get 方法。
**307**： 307 不会把 get 方法转成 post 会按照客户端发起的请求去请求资源

## HTTP 和 HTTPS

http 是明文传输的，所有的信息都可以被第三方抓包看清楚，对于一些敏感信息是不安全的，所以 HTTPS 就是为了解决这个问题出现的。

## HTTPS 安全性

HTTPS 的加密方案是将对称加密和非对称加密结合起来。

**对称加密**:双方公用一个秘钥，性能好，简单，但是秘钥容易被黑客破获

**非对称加密**: 优点是加密方案不会被破解，缺点是很慢，性能并不好

1. 公钥 + 私钥 = 秘钥对
2. 私钥加密的数据，只能对应的公钥打开，也就是一把钥匙开一把锁。。
3. 通信客户端和服务器都有自己的公钥，在通信之前，要把彼此的公钥发送给对方。
4. 然后通信双方用对方的公钥加密数据，然后把加密好的数据发给对方，对方再用自己本地的私钥解密数据

那么结合对称加密和非对称加密，将对称加密的秘钥使用非对称加密的公钥进行加密，然后发送出去，接收方用本地的私钥解密，这样就得到加密的秘钥，然后再用对称加密进行传输数据

### 中间人问题

上面的逻辑看着没问题，但是如果在通信双方的中间有个中间人，把原本双方需要互换的公钥全部换成自己的公钥，那么这时候就会出现中间人可以用自己的私钥轻松解密所有的数据。为了解决这个中间人信任问题就产生了 CA 证书，用来证明非第三方。

为了进一步防止 CA 证书被篡改引发安全问题，引入了数字签名，也叫做指纹。证书发布者根据指纹算法，一个 hash 算法，计算出整个证书的指纹 hash 值。然后使用者在使用的时候，也用 hash 算法计算一下指纹，如果这两个指纹对的上，就说明没有被篡改。
