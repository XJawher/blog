## 前情提要
React 18 发布了最新的测试版本，出现了并发模式，这是一个实验性的功能，因为我们的JS是一个单线程的语言，一次是只能干一件事情的，不能干更多的事情，处理数据，渲染dom，处理数据，渲染dom，虽然有了 webWorker，可以有更多的手段去处理数据，但是 webWorker 不能去修改 dom ，所以js单线程的本质还是没有被改变，那么 react 现在提出的这个 concurrent mode 并发模型是不是就可以去改变 js 的单线程的现状了呢，其实还是不行的，毕竟根基是单线程的，你上面楼再怎么盖，也不会出现多线程的建筑。

## React Concurrent Mode
在谈及并发模式之前，需要知道的是并行模式，一个 CPU 假设有 8 个进程，那么在有多个任务执行的时候，会出现同时去执行多个进程的情况，这个模式就是并行模式，目前我们的电脑基本都是这样的，其实 CPU 和我们 JS 的单线程有点相似，CPU 用极快的速度在不同的进程之间来回切换，让我们无感的去操作，仿佛是有很多的个核心在一起工作的样子。和 JS 类似的，我们 js 在 一帧的时间里，也是在不停的做处理数据，渲染dom，给我们带来流畅的体验，但是 react 之前的版本没有采用 fiber 算法的时候，是一个主线程执行完了以后，再去渲染，这时候如果数据量很大，一帧的时间无法处理完毕的时候， dom 就会出现卡帧的现象，也就是会卡顿，而最新的 fiber 算法就是采用了链表式的调度方案，在 react 16 版本之前采用的是 **栈** 的调度方案，栈的方案有一个问题就是当调度的栈很深的时候就会出现性能问题（递归，爆栈，尾递归优化），不能随意的 break掉。

**react 三层架构**
* **虚拟dom**: 虚拟 dom 层只负责描述结构和逻辑
* **内部组件层**：这一层负责组件的更新， ReactDOM.render setState 在合适的时间去执行各种组件的生命周期钩子
* **底层渲染层**： 不同的显示逻辑端有不同的渲染方法，显示器使用的是文本节点，元素节点等等，Native 端的时候调用 JAVA 的 GUI 等，在 canvas 中又有专门的api等等。

那么现在回到之前的问题当组件嵌套的很深的时候，可能就会出现性能问题，因为栈是不能被中断的，这时候 react 提出了一个新的架构就是 fiber。在 fiber 中一个 fiber 节点拥有 **return,child,sibling** 三个属性，分别对应父节点，第一个孩子节点，右边兄弟节点。有了他们，就可以把一棵树实现深度优化遍历。在fiber 架构中还有一个时间分片的概念，这是解决上面说的 栈 模式无法中断的一个很重要的概念，在 fiber 中会把任务分解很多个不同的优先级，然后去增量更新，这样就解决了栈时代的无法 breake 的情况。

所谓的并发模式，就是我们 CPU 在不停的去处理不同进程的数据，而这个处理的时间很短，对用户而言是无感的，这就是并发模式。而对浏览器而言，这个并发模式也是很相似的，在浏览器上有不同的进程，渲染进程，js 进程等等。