算法部分为 Sorting,Searching,Recursion,Backtracking,DP,DFS,BFS,Union Find Big O,Time vs space

## Sorting

排序算法有很多，最简单的就要数冒泡了，这个就不写了很简单。
目前我查到的 v8 在长度小于 10 的 时候是采用的插入排序，当大于 10 的时候采用的是插入排序，因此在这里就重点掌握这两种排序的算法。

### 插入排序

插入的工作原理是通过构建有序的序列，对没有排序的数据，在已经排序的序列中从后向前扫描，找到相应的位置并插入。插入排序在实现上通常是采用 in-place 排序，既只需要用到 O(1)的额外空间的排序。因而在扫描的过程中，需要反复把已经排序的元素逐步向后进行位移，为最新元素提供插入空间。
一般来说算法的实现是这样的

1. 从第一个元素开始，元素被认为是已经被排序。
2. 取出下一个元素，在已经排序的元素中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移动到下一个位置。
4. 重复步骤 3 ，直到找到已经排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置后。
6. 重复步骤 2~5

**插入排序的算法复杂度**
如果是把 n 个元素的序列进行升序排列或者降序排序，那么插入排序就存在着最好和最坏的情况，最好的情况是序列已经是升序排序了，在这种情况下，需要进行的比较操作是 n-1 即可。最坏的情况就是序列是降序排列，那么此时需要进行的比较就是 $\frac{1}{2}$n(n-1)，插入排序的赋值操作是比较操作的次数减去 n-1 次，因为在 n - 1 循环中，每一次循环的比较都比赋值多一个，多在最后的那个比较并不能带来赋值。平均来说插入排序的算法复杂度是 O($n^2$)。所以插入排序不适合大量的数据，当数据是千这个级别的时候，比较适合。或者数据是有一定的规律。
以下是代码算法实现。

```js
/**
 * @description
 * @author lipc
 * @date 18/03/2021
 * @param {Array<number>} params,需要排序的数组
 * @param {number} len,当前的第几个元素。
 * 1 从第一个元素开始，就默认这个元素是排好序的了
 * 2 取出下一个元素，在已经排序的元素中从后向前扫描
 * 3 如果该元素，大于新元素，将该元素移动到下一个位置
1. 从第一个元素开始，元素被认为是已经被排序。
2. 取出下一个元素，在已经排序的元素中从后向前扫描。
3. 如果该元素（已排序）大于新元素，将该元素移动到下一个位置。
4. 重复步骤 3 ，直到找到已经排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置后。
6. 重复步骤 2~5
 */
function insert(params) {
  // 默认的第一个元素是 数组的最后一个元素。
  for (let i = 0; i < params.length; i++) {
    for (let j = i; j > 0; j--) {
      // 这里是比较关键的地方，跳出的条件和循环的条件。
      if (params[j] > params[j - 1]) {
        // 这里是将 j 前面的所有的元素当做是一个新的数组，在这个数组中进行排序，因为排序是从 0 开始的
        // 可以认为每次开始之前的排序是都做好的，所以只需要对比一次就可以确定位置
        const tmp = params[j];
        params[j] = params[j - 1];
        params[j - 1] = tmp;
      }
    }
  }
  return params;
}
```

### 快速排序

快速排序使用了分治法策略来把一个序列分为较小和较大两个子序列，然后递归的排序这两个子序列。

1. 挑选基准值：从数列中选择一个元素，称之为 “基准”（pivot）
2. 分割：重新排序子序列，所有比基准值小的放在左边，比基准值大的放在右边，于基准值相等的可以不变，这个分割结束以后对于基准值的分割就结束。
3. 递归排序子序列：递归的将步骤 2 排序好的左右序列进行递归排序。

递归到底部的判断条件是数量的大小是零或者一，此时的数列是已经有序的。
选取基准值对算法的性能有一定的影响。
在 V8 的 sort 算法中选择的是插入和快排，数量小的时候采用插入，数量大的时候选择的是快排。这是因为快排是一种最佳和平均时间复杂度都可以是$xlog(x)$,是一种应用非常广泛的排序算法。
快排的核心就是不断的把数组进行切分，切分成小数组以后继续将小数组进行切分。

代码实现

```js
function quickBase(arr) {
  if (!arr || !arr.length) return [];

  // 中断递归的条件
  if (arr.length < 2) return arr;

  // 基准值的选择,基准值的选择有很多的方案,有的是直接选择的数组开头的值，有的是选择的数组最后的值
  // 随机
  // const pivot = Math.floor(Math.random() * arr.length)
  // 开头
  // const pivot = 0
  // 结尾
  const pivot = arr.length - 1;

  // 声明左右数组，大的往 big 走，小的往 small 走
  const smallArray = [];
  const bigArray = [];
  // 按照 pivot 的值选择数据
  for (let index = 0; index < arr.length; index++) {
    // 相等的可以放到大的组也可以放到小的组
    if (arr[pivot] >= arr[index] && index !== pivot) {
      // 大的值进大的数组
      bigArray.push(arr[index]);
    }

    if (arr[pivot] < arr[index] && index !== pivot) {
      // 小的值进小的数组
      smallArray.push(arr[index]);
    }
  }
  return [...quickBase(bigArray), arr[pivot], ...quickBase(smallArray)];
}
```

上面的算法实现是一个很基础的版本，还有很多是社区里改进的版本。这里就不做更新了。

## Searching

## Recursion

## Backtracking

## DP

## DFS

## BFS

## Union Find Big O

## Time vs space
